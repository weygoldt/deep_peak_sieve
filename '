from pathlib import Path
from scipy.signal import find_peaks
import numpy as np
import matplotlib.pyplot as plt
from audioio.audioloader import AudioLoader
from deep_peak_sieve.utils.loggers import get_logger, get_progress, configure_logging
from IPython import embed

log = get_logger(__name__)


def collect_peaks(path: Path, buffersize: int = 60 * 5):
    if not path.exists():
        raise FileNotFoundError(f"Path {path} does not exist.")
    elif path.is_dir():
        log.info("Dataset is a directory, processing each file.")
        files = sorted(list(path.glob("*.wav")))
        files = [str(file) for file in files]
        data = AudioLoader(files)
    else:
        log.info("Dataset is a single file.")
        data = AudioLoader(str(path))

    blocksize = int(np.ceil(data.rate * buffersize))
    overlap = int(np.ceil(blocksize // 2))
    log.info(
        f"Buffer size: {buffersize} seconds\nBlock size: {blocksize} samples\nsampling rate: {data.rate} Hz\n{data.channels} channels\n"
    )

    for i, block in enumerate(data.blocks(block_size=blocksize, noverlap=overlap)):
        if data.channels == 1:
            block = np.expand_dims(block, axis=1)

        mean = np.mean(block, axis=0)
        std = np.std(block, axis=0)

        peaks = [
            find_peaks(block[:, ch], prominence=std[ch] * 2)[0]
            for ch in range(data.channels)
        ]

        fig, axs = plt.subplots(
            data.channels, 1, figsize=(8, 4), constrained_layout=True
        )
        for ch in range(data.channels):
            axs[ch].plot(block[:, ch], label=f"Channel {ch}")
            axs[ch].plot(peaks[ch], block[peaks[ch], ch], "x", label="Peaks")
            axs[ch].set_title(f"Block {i} Channel {ch}")
            axs[ch].legend()
            axs[ch].set_xlabel("Samples")
            axs[ch].set_ylabel("Amplitude")
        plt.show()

        print(f"Mean: {mean}")
        print(f"Std: {std}")


def main():
    configure_logging(verbosity=10)
    path = Path(__file__).parent.parent.parent.parent / "testdata"
    collect_peaks(path=path)
